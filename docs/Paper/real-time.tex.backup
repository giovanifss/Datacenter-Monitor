\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}

\usepackage[brazil]{babel}   
%\usepackage[latin1]{inputenc}  
\usepackage[utf8]{inputenc}  
% UTF-8 encoding is recommended by ShareLaTex

\usepackage{amsmath}

% Desenho do grafo
\usepackage{tikz}
     
\sloppy

\title{Instructions for Authors of SBC Conferences\\ Papers and Abstracts}

\author{Giovani Ferreira\inst{1}, Gustavo Coimbra\inst{1}, Eduardo San\inst{1} }


\address{CEUB - Centro Universitário de Brasília \\
  Caixa Postal 4488 -- 70.904-970 -- Brasília -- DF -- Brazil
}

\begin{document} 

\maketitle

\begin{abstract}
\end{abstract}
     
\begin{resumo} 
\end{resumo}


\section{Introduction}

Nowadays, most business operations are supported by IT systems. Therefore, their availability is critical to keep
business running smoothly and continuously. In order to provide high quality IT services, a well-managed data center
is required to house computer servers, storage systems,network devices, and their associated components. Downtime
of the data center can be costly resulting in production and business losses so that the high availability requirement of the
data center is needed.
Data center always requires a non-stopped service or 24x7 availability. The availability of data center mainly requires the
protection of computer equipment and personnel. There are some potential hazards which may occur and impact the
availability of data center. Fire is the most potential hazard which can create severe effects on data center. Fire can occur
in a data center by mechanical failure, intentional arson, or natural causes.
Data Center Physical Security Ontology for Automated Evaluation (Abstract).

Data Center is a facility used for housing a large amount of computer and communications equipment maintained by an
organization for the purpose of handling the data necessary for its operations.
Glossary of MMC Terminology. Available: http://msdn.microsoft.com/en-us/library/bb246417(VS.85).aspx.

\section{Related Concepts}

\subsection{Time}

It's important to understand what is time and it's related concepts. For this purpose, the definitions provided by
\cite{kopetz2011real} will be considered: 
\begin{itemize}
 \item The flow of time is a directed time line that extends from the past into the future.
 \item A cut of the time line is called an instant.
 \item Any ideal occurrence that happens at an instant is called an event.
 \item The present point in time, now, is a very special event that separates the past from the future.
 \item An interval on the time line, called a duration, is defined by two events, the start event and the 
terminating event of the interval.
 \item The instant when a result must be produced is called a deadline.
\end{itemize}

In the context of deadlines, \cite{kopetz2011real} also provides a good definition, classifying them in 
three different ways:
\begin{enumerate}
 \item Soft deadline: If a result has utility even after the deadline has passed,
 \item Firm deadline: If a result does not matter after the deadline.
 \item Hard deadline: If severe consequences could result if a firm deadline is missed.
\end{enumerate}

\subsection{Real-time systems}

% For \cite{kopetz2011real}, a real-time computer system is a computer system where the correctness 
% of the system behavior depends not only on the logical results of the computations, but also on 
% the physical time when these results are produced. \cite{ayeni2012real} completes this definition stating
% that correctness of a system refers to the behaviour of the system over time.

For \cite{kopetz2011real}, a real-time computer system is a computer system where the correctness 
of the system behavior depends not only on the logical results of the computations, but also on 
the physical time when these results are produced. \cite{lichtenstein1985glory} states that a real-time system 
is a reactive system, that is, it must react to stimuli from its environment within time intervals dictated by 
its environment. According to \cite{stankovic1990predictability}, a real-time computer system can be classified 
in 2 different ways:
\begin{enumerate}
 \item Static real-time system: where all deadlines can be guaranteed a priori.
 \item Dynamic real-time system: large, complex, distributed, adaptive, contain many types of timing constraints, 
need to operate in a highly nondeterministic environment, and evolves over a long system lifetime.
\end{enumerate}

The type of the deadline affects the real-time system. If the system must met at least
one hard deadline, it's called a hard real-time computer system.  If no hard deadline exists, 
then the system is called a soft real-time computer system. The design of a hard real-time system is 
fundamentally different from the design of a soft real-time system. While the first must sustain a guaranteed 
temporal behavior under all specified load and fault conditions, it is permissible for the second to miss a 
deadline occasionally \cite{kopetz2011real}. \cite{stankovic1996real} also points that hard real-time systems 
usually cause several consequences, even death, when missed an important deadline.

\subsection{Tasks}

For \cite{stankovic1996real} tasks can be classified as:

\begin{itemize}
  \item Periodic task: activated every T units. The deadline for each activated instance may be less than, equal to, 
or greater than the period T.
  \item Aperiodic task: activated at unpredictable times.
  \item Sporadic task: an aperiodic task with the additional constraint that there is a minimum interarrival time 
between task activations.
\end{itemize}

Real-time scheduling is the process of creating start and finish times for sets of tasks such that
all timing, precedence, and resource constraints are met.

%Rate monotonic algorithm assigns the highest priority to the most frequent periodic task. \cite{stankovic1996real}

\iffalse

Predictability of the system means that it should be possible to show, demonstrate, or prove that requirements are
met subject to any assumptions made, for example, concerning failures and workloads. In other words, 
predictability is always subject to the underlying assumptions being made.

The strictness of the deadline refers to the value of executing a task after its deadline. For a hard real-time 
task there is no value to executing the task after the deadline has passed. A soft real-time task retains some 
diminished value after its deadline so it should still be executed.

The environment in which a real-time system is to operate plays an important role in the
design of the system. Many environments are very well defined (such as a lab experiment,
an automobile engine, or an assembly line). Designers think of these as deterministic envi-
ronments (even though they may not be intrinsically deterministic, they are forced to be).
These environments give rise to small, static real-time systems where all deadlines can
be guaranteed a priori. Since we know exactly what to expect given the assumptions about the 
well defined environment we can consider these systems to be predictable.

The problem is that the approaches taken in relatively small, static systems do not scale
to other environments which are larger, much more complicated, and less controllable.
Consider a next generation real-time system such as a team of cooperating mobile robots
on Mars. This next generation real-time system will be large, complex, distributed, adap-
tive, contain many types of timing constraints, need to operate in a highly nondeterministic
environment, and evolves over a long system lifetime. We consider this type of real-time system to be
a dynamic real-time system operating in a nondeterministic environment. \cite{stankovic1990predictability}

A computation of a real-time system can be viewed as a sequence of event occurrences. Informally, 
events represent things that happen in a system. An event occurrence defines a point in time in a
computation at which a particular instance of an event happens. \cite{chodrow1991run}

The reliability of a system is the probability that a system will provide the specified service until time t.
The probability that a system will fail in a given interval of time is expressed by the failure rate, 
measured in FIT's (Failure In Time). A failure rate of 1 FIT means that the mean time to a failure (MTTF) 
of a device is 10\^9 h, i.e., one failure occurs in about 115,000 years.
If a system has a constat failure rate of (lambda) failures/h, then the reliability at time t is giben by:
R(t) = exp(-lambda(t - t0)). \cite{kopetz2011real}

\fi

\section{The RTDMS}

The RTDMS, that stands for Real Time Datacenter Monitor System, is a real time system aiming
to provide a reliable and solid way to measure and monitor the conditions of a datacenter. Using
sensors for temperature, humidity and flood, the RTDMS is able to quickly discover adverse conditions
in a datacenter and reduce the warning time, so the support team have more time to take the
appropriate interventions and avoid worse situations.

\subsection{Tasks Model}
The RTDMS have the following tasks model:

\begin{table}
    \begin{tabular}{|c|c|c|c|}
        \hline
        \textbf{Task Name}& \textbf{Period (ms)}& \textbf{Computation Time (ms)}& \textbf{Deadline Type} \\ \hline
        Alarm             & Aperiodic   & 400                   & Hard          \\ \hline
        Check Flood       & 1000        & 30                    & Soft          \\ \hline
        Check Temperature & 1000        & 820                   & Soft          \\ \hline
        Check Humidity    & 1000        & 20                    & Soft          \\
        \hline
    \end{tabular}
\end{table}

\begin{itemize}
 \item Alarm Task: Responsible to warn that something went wrong in datacenter. The deadline is hard. To assure
 that the deadline will be fulfilled, this task blocks the execution of the other tasks and monopolizes the hardware.
 \item Check Flood: This task uses a rain sersor to check if there is a water flood in datacenter. The deadline is
 soft because if it fails sometimes, it's not a problem. An undetected flood a second and half ago does not reach
 very high levels in this hiatus. If the tasks detects a failure in the sensors, it activates the alarm task to warn
 that something is wrong.
 \item Check Temperature: Responsible to collect the data from the temperature sensors and treat them to provide
 a realiable measure. The deadline is soft, the temperature will not change abruptly in one second and half. The
 validation of the temperatures measured can deal with a failure of one sensor (measuring a absurd temperature value
 or not measuring anything).
 \item Check Humidity: Collect the data from humidity sensors and process it to provide a valid humidity measure. If the
 dealine fail sometimes, it's not a problem, humidity needs more time to significantly changes. This task can deal with 
 failure of one sensor, correcting the measure and providing a correct final result.
\end{itemize}


%\begin{center}
\begin{tikzpicture}[scale=0.2]
  \tikzstyle{every node}+=[inner sep=0pt]
  \draw [black] (11.2,-13.1) circle (3);
  \draw (11.2,-13.1) node {$IS$};
  \draw [black] (11.2,-13.1) circle (2.4);
  \draw [black] (31,-13.1) circle (3);
  \draw (31,-13.1) node {$CT$};
  \draw [black] (31,-33.7) circle (3);
  \draw (31,-33.7) node {$CF$};
  \draw [black] (61.4,-17.3) circle (3);
  \draw (61.4,-17.3) node {$AM$};
  \draw [black] (14.2,-13.1) -- (28,-13.1);
  \fill [black] (28,-13.1) -- (27.2,-12.6) -- (27.2,-13.6);
  \draw (21.1,-13.6) node [below] {$1$};
  \draw [black] (9.877,-10.42) arc (234:-54:2.25);
  \draw (11.2,-5.85) node [above] {$0$};
  \fill [black] (12.52,-10.42) -- (13.4,-10.07) -- (12.59,-9.48);
  \draw [black] (29.723,-30.988) arc (-158.8625:-201.1375:21.043);
  \fill [black] (29.72,-30.99) -- (29.9,-30.06) -- (28.97,-30.42);
  \draw (27.81,-23.4) node [left] {$0$};
  \draw [black] (58.45,-17.841) arc (-81.54867:-114.18346:44.476);
  \fill [black] (58.45,-17.84) -- (57.58,-17.46) -- (57.73,-18.45);
  \draw (45.45,-18.51) node [below] {$1$};
  \draw [black] (60.602,-20.19) arc (-19.25615:-104.05246:22.537);
  \fill [black] (60.6,-20.19) -- (59.87,-20.78) -- (60.81,-21.11);
  \draw (51.17,-33.09) node [below] {$1$};
  \draw [black] (32.197,-15.848) arc (19.70004:-19.70004:22.402);
  \fill [black] (32.2,-15.85) -- (32,-16.77) -- (32.94,-16.43);
  \draw (34.01,-23.4) node [right] {$0$};
  \draw [black] (60.077,-14.62) arc (234:-54:2.25);
  \draw (61.4,-10.05) node [above] {$1$};
  \fill [black] (62.72,-14.62) -- (63.6,-14.27) -- (62.79,-13.68);
  \draw [black] (33.909,-12.37) arc (101.78619:62.48167:37.354);
  \fill [black] (33.91,-12.37) -- (34.79,-12.7) -- (34.59,-11.72);
  \draw (47.03,-11.33) node [above] {$0$};
\end{tikzpicture}

\begin{itemize}
 \item IS: Initial State. Outputs '1' when the system is activated;
 \item AM: Alarm. Outputs '0' when is turned off manually;
 \item CF: Check Flood. Outputs '1' when identifies a considerable amount of water;
 \item CT: Check Temperature. Outputs '1' when identifies a temperature above what it should be.
\end{itemize}

\subsubsection{Time Restrictions}

The RTDMS time restriction is the warning time. In the moment that RTDMS detects an adverse condition,
the alarm task must be execute instantly. The failure of this task, not warning or warning with delay,
can cause big problems to the owners of the datacenter, including the loss of all data and equipments.

\subsubsection{Scalability}

The rate monotonic, which assigns a higher priority to a task with shorter period, was considered an
optimal fixed priority algorithm by \cite{liu1973scheduling}, which proved that for a set of \(n\) periodic 
tasks with unique periods, a feasible schedule that will always meet deadlines exists if the CPU 
utilization is below a specific bound (depending on the number of tasks). The schedulability test 
for Rate Monotonic Scheduler is:

\[ \displaystyle U = \sum_{i=1}^{n}\frac{C_i}{P_i} \leq n(2^\frac{1}{n} - 1) \]

Where \(U\) is the CPU utilization, \(C_i\) is the computation time of the task \(i\), \(P_i\) is the release period (with deadline one period after),
and \(n\) is the number of processes to be scheduled.

The set of tasks for RTDMS was mathematically proved as scalable:

\begin{enumerate}
 \item Check Flood: \[ C_1 = \frac{C_1}{P_1} = \frac{30}{1500} = 0.0200 \]
 \item Check Temperature: \[ C_2 = \frac{C_2}{P_2} = \frac{820}{1500} = 0.5467 \]
 \item Check Humidity: \[ C_3 = \frac{C_3}{P_3} = \frac{20}{1500} = 0.0133 \]
\end{enumerate}

\[ U = \sum_{i=1}^{3}\frac{C_i}{P_i} = 0.7600 \leq 3(2^\frac{1}{3} - 1) = 0.7797 \]

\[ U = 0.7600 \leq 0.7797 \]

This set of tasks were submitted to simulation in XXXX(nome da ferramenta) and was proved as scalable:

[Imagem da ferramenta mostrando que eh escalonavel]

\section{Experiments and Evaluation}

The prototype implementation of RTDMS consisted in the following hardware equipments:
\begin{itemize}
 \item 1x - Arduino Uno
 \item 3x - Temperature and humidity sensors
 \item 1x - Rain sensor
 \item 1x - Buzzer
 \item 1x - Potentiometer
\end{itemize}

This prototype used the NilRTOS implementation of the Rate Monotonic algorithm available in 
https://github.com/greiman/NilRTOS-Arduino .

The source code for this prototype can be found in https://github.com/giovanifss/Datacenter-Monitor .

\section{Conclusion}

\bibliographystyle{sbc}
\bibliography{real-time}

\end{document}
